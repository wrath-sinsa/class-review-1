# Compiler 1주차 1

## 컴파일러 개요

### 컴파일러의 정의

- 컴파일러는 형식 언어를 번역하며 `high level language`인 소스 프로그램(`Source Program`)을 컴파일러(`Compiler`)를 통해 `low level language`인 타켓 프로그램(`Target Program`: object code 또는 machine code)으로 만드는 역할을 한다.

  > Jeffrey David Ullman은 이렇게 정의한다.
  > _컴파일러는 high level programming language로 작성된 프로그램을 특정 컴퓨터에 적합하게 실행 가능한 코드로 번역하게 해주는 컴퓨터 프로그램이다._

### 컴파일과 번역의 차이

- 컴파일과 번역은 말 그대로 `translate`한다는 점에서는 의미가 같으나. **누구에게 번역이 되느냐에 따라** 달라지게 된다. 예시를 들어보자.

  ```
  번역 전
  2와 3의 합은 5이다.

  번역 후
  Adding 2 to 3 is 5.
  ```

  한국어로 되어있는 표현을 영어로 번역하여 표현하였는데, `사람(man)`을 대상으로 번역하였기 때문에 컴파일이라기보다는 번역의 의미에 가깝다.

  아래의 예시도 함께 보자.

  ```
  번역 전
  a = 2;
  b = 3;
  c = a + b;

  번역 후
  LD A, #02
  LD B, #03
  ADD A B
  ```

  번역 전의 코드는 `사람(man)`이 읽기 쉬운 `high level language`이고, 번역이 끝난 후 코드는 `컴퓨터(computer)`가 읽을 수 있는(또는 실행 가능한) `low level language`로 번역된 모습이다.  
  이와 같이 사람 대 컴퓨터, `high level`을 `low level`로 번역되는 것을 우리는 `컴파일` 또는 `인터프리트`라 부른다.

  > 컴파일(Compile): 코드를 생성하는 것 까지
  > 인터프리트(Interpret): 실행한 결과를 보여주는 것 까지

### 컴파일러 구조

- [정의](#컴파일러의-정의)에서 살펴보았듯이 `Source Program`을 받아 `Target Program`으로 만드는 역할을 하는 것이 `Compiler`인데, 이 `Compiler`가 어떻게 되어있길래 저렇게 번역이 가능한걸까?  
  이를 이해하기 위해 내부 구조를 살펴보자!

  ***

  <img width="1090" alt="스크린샷 2021-03-04 오후 5 35 48" src="https://user-images.githubusercontent.com/57972338/109934663-1fb77e80-7d10-11eb-8f59-7b7d46eb3805.png">

  ***

  - `Front-End`(전반부): 형식 언어 분석을 담당하기 때문에 언어에 종속(`language dependent`)된다.
  - `Back-End`(후반부): 머신 코드를 생성하는 역할을 하기 때문에 실행하는 기계에 종속(`machine dependent`)된다.
  - `IC(Intermediate Code)`(중간코드): `Front-End`에서 작업한 후 `Back-End`에 코드를 보낼 때 중간코드인 를 생성해서 보낸다.
    > IC는 기계랑은 전혀 상관없는 중간코드이다.

- 위 구조를 통해 `Front-End`와 `Back-End`로 나뉘지만 일어나는 작업의 성격은 완전히 다르다는 것을 알 수 있다.

  > 우리는 주로 전반부에 해당하는 `Front-End` 부분을 자세하게 다룰 예정이다.

- **그렇다면, 컴파일러는 단순히 Front-End -> IC -> Back-End로만 작동되어지는가?**

  > That's no no 그렇지 않당!

  ***

  <img width="1120" alt="스크린샷 2021-03-04 오후 5 36 50" src="https://user-images.githubusercontent.com/57972338/109934769-3958c600-7d10-11eb-8c1a-1c5033ddc272.png">

  ***

  - 컴파일러가 동작되기 위해선 두 개의 테이블이 필요하다.
    - Symbol Table: 기호를 저장하는 테이블
      > _ex. variables, functions ..._
    - Literal Table: 상수를 저장하는 테이블
      > _3.14, "Park" ..._

  <!-- TODO: 컴파일러 개요 2, 5분부터 확인! -->
