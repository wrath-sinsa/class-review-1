# Compiler 1주차 1

## 컴파일러 개요

### 컴파일러의 정의

- 컴파일러는 형식 언어를 번역하며 `high level language`인 소스 프로그램(`Source Program`)을 컴파일러(`Compiler`)를 통해 `low level language`인 타켓 프로그램(`Target Program`: object code 또는 machine code)으로 만드는 역할을 한다.

  > Jeffrey David Ullman은 이렇게 정의한다.  
  > _컴파일러는 high level programming language로 작성된 프로그램을 특정 컴퓨터에 적합하게 실행 가능한 코드로 번역하게 해주는 컴퓨터 프로그램이다._

### 컴파일과 번역의 차이

- 컴파일과 번역은 말 그대로 `translate`한다는 점에서는 의미가 같으나. **어느 대상에게 번역이 되느냐에 따라** 달라지게 된다. 예시를 들어보자.

  ```
  번역 전
  2와 3의 합은 5이다.

  번역 후
  Adding 2 to 3 is 5.
  ```

  한국어로 되어있는 표현을 영어로 번역하여 표현하였는데, `사람(man)`을 대상으로 번역하였기 때문에 컴파일이라기보다는 번역의 의미에 가깝다.

  아래의 예시도 함께 보자.

  ```
  번역 전
  a = 2;
  b = 3;
  c = a + b;

  번역 후
  LD A, #02
  LD B, #03
  ADD A B
  ```

  번역 전의 코드는 `사람(man)`이 읽기 쉬운 `high level language`이고, 번역이 끝난 후 코드는 `컴퓨터(computer)`가 읽을 수 있는(또는 실행 가능한) `low level language`로 번역된 모습이다.  
  이와 같이 사람 대 컴퓨터, `high level`을 `low level`로 번역되는 것을 우리는 `컴파일` 또는 `인터프리트`라 부른다.

  > 컴파일(Compile): 코드를 생성하는 것 까지  
  > 인터프리트(Interpret): 실행한 결과를 보여주는 것 까지

### 컴파일러 구조

- [정의](#컴파일러의-정의)에서 살펴보았듯이 `Source Program`을 받아 `Target Program`으로 만드는 역할을 하는 것이 `Compiler`인데, 이 `Compiler`가 어떻게 되어있길래 저렇게 번역이 가능한걸까?  
  이를 이해하기 위해 내부 구조를 살펴보자!

  ***

  <img width="1090" alt="스크린샷 2021-03-04 오후 5 35 48" src="https://user-images.githubusercontent.com/57972338/109934663-1fb77e80-7d10-11eb-8f59-7b7d46eb3805.png">

  ***

  - `Front-End`(전반부): 형식 언어 분석을 담당하기 때문에 언어에 종속(`language dependent`)된다.
  - `Back-End`(후반부): 머신 코드를 생성하는 역할을 하기 때문에 실행하는 기계에 종속(`machine dependent`)된다.
  - `IC(Intermediate Code)`(중간코드): `Front-End`에서 작업한 후 `Back-End`에 코드를 보낼 때 중간코드인 를 생성해서 보낸다.
    > IC는 기계랑은 전혀 상관없는 중간코드이다.

- 위 구조를 통해 `Front-End`와 `Back-End`로 나뉘지만 일어나는 작업의 성격은 완전히 다르다는 것을 알 수 있다.

  > 우리는 주로 전반부에 해당하는 `Front-End` 부분을 자세하게 다룰 예정이다.

#### 구제적인 컴파일러 구조

- **그렇다면, 컴파일러는 단순히 Front-End -> IC -> Back-End로만 작동되어지는가?**

  > That's no no 그렇지 않당!

  ***

  <img width="1120" alt="스크린샷 2021-03-04 오후 5 36 50" src="https://user-images.githubusercontent.com/57972338/109934769-3958c600-7d10-11eb-8c1a-1c5033ddc272.png">

  ***

  - 컴파일러가 동작되기 위해선 두 개의 테이블이 필요하다.
    - Symbol Table: 기호를 저장하는 테이블
      > _ex. variables, functions ..._
    - Literal Table: 상수를 저장하는 테이블
      > _3.14, "Park" ..._

- 두 개의 테이블이 필요한 이유는 `Front-End`에서 형식 언어를 처리하면서 그 언어로 써져 있는 변수나, 상수, 함수 등을 저장할 공간이 필요로 하게 되고 `Back-End`에서 이를 참조하여 처리해야하기 때문에 두 개의 테이블을 두는 것이다.

- 또한 형식 언어의 규칙에 맞게 작성이 되어있지 않으면 에러가 발생하기 때문에 이를 관리하기위한 에러 핸들링 파트도 필요하다.

##### 추가로

- `Front-End`는 언어종속적이기 때문에 굉장히 알고리즘이 잘 만들어져있고 이론적인 분석이 가능한 파트이며 `Back-End`는 이를 가지고 Synthesis(합성)하는 단계인데 알고리즘화되어있지 않고 감춰저있다.

## Front-End

- `Front-End`도 역시 한 번에 결과가 나오는 것이 아니라 세부적인 phase로 나뉘어져 동작하게 된다. 이는 다음과 같다.
  - Scanner(Lexical Analyzer): Source Code를 받아 `Token`을 만듦
  - Parser(Syntax Analyzer): `Token`을 가지고 `Syntax tree`(구문트리)를 만듦
  - Semantic Analyzer: `Syntax tree`를 가지고 `Annotated tree`를 만듦
    > Annotation: 주석(상세한 정보를 추가했다는 의미)

### Scanner(Lexical Analyzer)

- 어휘분석하여 토큰을 찾는 역할을 한다. 아래 예시를 보자
  ```
  a[index] = 4 + 2
  ```
  위 코드에 대한 토큰은 아래와 같다.
  |Token|Meaning|
  |:---:|:---:|
  |a|identifier(변수)|
  |[|left bracket|
  |index|identifier|
  |]|right bracket|
  |=|assignment(연산 기호)|
  |4|number(literal, 숫자상수)|
  |+|plus sign(연산 기호)|
  |2|number|
  > 여기서 주석이나 tab, newline 과 같은 것은 이 파트에서 제거된다.

### Parser(Syntax Analyzer)

- 컴파일러에서 가장 핵심이 되는 녀석이며 `token`을 통해 이 문장(statement)이 어떤 문장인지를 구문분석(문장의 구조를 분석하는 것)하는 과정이다.

- 예를 들면 위 과정에서 나온 `token`을 가지고 보았을 때 이 등호(=) 표시를 통해 assignment statement라는 것을 알 수 있다. 그렇기 때문에
`LHS variable = RHS expression` 구성방식일 것이다.
<!-- TODO: 정리가 이렇게 빡셀줄은 몰랐지... -->
